// serie Fibonnaci 
// recursivo 

 def fib(n:Int) : Int = 
 {
     if (n<2){n  
     }
     else 
     { 
         fib(n-1)+fib(n-2)
     }

 }
 for (i<-1 to 10)
 println(fib(i))

 //Fiboniacci Recursivo
 
val n = 10

def fibonacci1(n:Int) : Int =
{
if (n<2)
{
return n
}
else
{
    return fibonacci1(n-1) + fibonacci1(n-2)
}
}  

println(fibonacci1(n))



//Algoritmo 2 Versión con fórmula explícita (6) (Complejidad O  

val n = 4
var phi=((1+math.sqrt(5))/2)
var j=((math.pow(phi,n)-math.pow((1-phi),n))/(math.sqrt(5)))

def fibonacci2(n:Double) : Double ={
if (n<2){
return n
}
else {

    return j
}
}
println(fibonacci2(n))



//Algoritmo 3 Versión iterativa

def fibonacci3(n:Int):Int=
{
var n : Int = 6
var a = 0
var b = 1
var c = 0
var k = 0 

    for(k <- 1 to n) 
    {
        
        c = b + a
        a = b
        b = c 
    }
     return a
}
println(fibonacci3(n))


// 4. Crea un arreglo de numero en rango del 1-1000 en pasos de 5 en 5

val array = (1 to 1000).by(5)
    for(i <- array){
        println(""+i)

    }


// 5. Cuales son los elementos unicos de la lista Lista(1,3,3,4,6,7,3,7) utilice conversion a conjuntos

val mylist = List(1,3,3,4,5,7,3,7)
    mylist.toSet

// 6. Crea una mapa mutable llamado nombres que contenga los siguiente
//     "Jose", 20, "Luis", 24, "Ana", 23, "Susana", "27"
// 6 a . Imprime todas la llaves del mapa

val nombres = collection.mutable.Map(("Jose",20),("Luis",24),("Ana",23),("Susana",27))
nombres.keys

// 7 b . Agrega el siguiente valor al mapa("Miguel", 23)

nombres += ("Miguel" -> 23)

